% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcpfit_methods.R
\encoding{UTF-8}
\name{execute-mcp-model}
\alias{execute-mcp-model}
\alias{predict.mcpfit}
\alias{predict}
\alias{fitted.mcpfit}
\alias{fitted}
\alias{logLik.mcpfit}
\alias{log_lik.mcpfit}
\alias{log_lik}
\alias{residuals.mcpfit}
\alias{residuals}
\title{Fitted and predicted values of \code{mcp} models fits}
\usage{
\method{predict}{mcpfit}(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  rate = TRUE,
  prior = FALSE,
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  samples_format = "tidy",
  ...
)

\method{fitted}{mcpfit}(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  rate = TRUE,
  prior = FALSE,
  dpar = "epred",
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  samples_format = "tidy",
  scale = "response",
  ...
)

\method{logLik}{mcpfit}(object, ...)

\method{log_lik}{mcpfit}(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  rate = TRUE,
  prior = FALSE,
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  samples_format = "tidy",
  ...
)

\method{residuals}{mcpfit}(
  object,
  newdata = NULL,
  summary = TRUE,
  probs = TRUE,
  prior = FALSE,
  varying = TRUE,
  arma = TRUE,
  nsamples = NULL,
  ...
)
}
\arguments{
\item{object}{An \code{mcpfit} object.}

\item{newdata}{A \code{tibble} or a \code{data.frame} containing predictors in the model. If \code{NULL} (default),
the original data is used.}

\item{summary}{Summarise at each x-value}

\item{probs}{Vector of quantiles. Only in effect when \code{summary == TRUE}.}

\item{rate}{Boolean. For binomial models, plot on raw data (\code{rate = FALSE}) or
response divided by number of trials (\code{rate = TRUE}). If FALSE, linear
interpolation on trial number is used to infer trials at a particular x.}

\item{prior}{TRUE/FALSE. Plot using prior samples? Useful for \code{mcp(..., sample = "both")}}

\item{varying}{One of:
\itemize{
\item \code{TRUE} All varying effects (\code{fit$pars$varying}).
\item \code{FALSE} No varying effects (\code{c()}).
\item Character vector: Only include specified varying parameters - see \code{fit$pars$varying}.
}}

\item{arma}{Whether to include autoregressive effects.
\itemize{
\item \code{TRUE} Compute autoregressive residuals. Requires the response variable in \code{newdata}.
\item \code{FALSE} Disregard the autoregressive effects. For \code{family = gaussian()}, \code{predict()} just use \code{sigma} for residuals.
}}

\item{nsamples}{Integer or \code{NULL}. Number of samples to return/summarise.
If there are varying effects, this is the number of samples from each varying group.
\code{NULL} means "all". Ignored if both are \code{FALSE}. More samples trade speed for accuracy.}

\item{samples_format}{One of "tidy" or "matrix". Controls the output format when \code{summary == FALSE}.
See more under "value"}

\item{...}{Currently ignored.}

\item{dpar}{What distributional parameter to evaluate. This is only relevant when \code{type == "fitted"}. E.g.,
\itemize{
\item \code{"epred"} (default): Expected value of the full model (or \code{NULL} for compatibility with brms etc.).
\item \code{"mu"}: The central tendency which is often the mean after applying the
link function.
\item \code{"sigma"}: The standard deviation of the residuals.
\item \code{"ar1"}, \code{"ar2"}, etc. depending on which order of the autoregressive
effects you want to plot.
}}

\item{scale}{One of
\itemize{
\item \code{"response"}: return on the observed scale, i.e., after applying the inverse link function.
\item \code{"linear"}: return on the parameter scale (where the linear trends are modelled).
A linear scale is only applicable when \code{type == "fitted"} and \code{dpar} is not \code{NULL}.
}}
}
\value{
\itemize{
\item If \code{summary = TRUE}: A \code{tibble} with the posterior mean for each row in \code{newdata},
If \code{newdata} is \code{NULL}, the data in \code{fit$data} is used.
\item If \code{summary = FALSE} and \code{samples_format = "tidy"}: A \code{tidybayes} \code{tibble} with all the posterior
samples (\code{Ns}) evaluated at each row in \code{newdata} (\code{Nn}), i.e., with \verb{Ns x Nn} rows. If there are
varying effects, the returned data is expanded with the relevant levels for each row.

The return columns are:
\itemize{
\item Predictors from \code{newdata}.
\item Sample descriptors: ".chain", ".iter", ".draw" (see the \code{tidybayes} package for more), and "data_row" (\code{newdata} rownumber)
\item Sample values: one column for each parameter in the model.
\item The estimate. Either "predict" or "fitted", i.e., the name of the \code{type} argument.
}
\item If \code{summary = FALSE} and \code{samples_format = "matrix"}: An \code{N_draws} X \code{nrows(newdata)} matrix with fitted/predicted
values (depending on \code{type}). This format is used by \code{brms} and it's useful as \code{yrep} in
\verb{bayesplot::ppc_*} functions.
}
}
\description{
Evaluate the model on data, either summarised (per data-row) or per draw. You
can use draws from the prior (\code{prior = TRUE}), select the parameter to predict
from (``)
}
\details{
\code{residuals(fit)} is equivalent to  \code{fitted(fit, ...) - fit$data[, fit$data$yvar]} (or \code{fitted(fit, ...) - newdata[, fit$data$yvar]}),
but with fixed arguments for \code{fitted}: \verb{rate = FALSE, dpar = 'mu', samples_format = 'tidy'}.
}
\section{Functions}{
\itemize{
\item \code{predict(mcpfit)}: Predictive Distribution

\item \code{fitted(mcpfit)}: Expected distribution

\item \code{logLik(mcpfit)}: Alias for built-in method

\item \code{log_lik(mcpfit)}: Pointwise log-likelihood

\item \code{residuals(mcpfit)}: Residual distribution

}}
\examples{
fitted(demo_fit)  # Expected value at each demo_fit$data at response-level
residuals(demo_fit)  # Residuals at each demo_fit$data at response-level
log_lik(demo_fit)  # Log-likelihood at each demo_fit$data

# All of the above take a range of arguments. E.g.,:
\donttest{
predict(demo_fit)  # Pointwise posterior predictive
predict(demo_fit, probs = c(0.1, 0.5, 0.9))  # With median and 80\% credible interval.
predict(demo_fit, prior = TRUE)  # Prior predictive
fitted(demo_fit, summary = FALSE)  # Samples instead of summary. Useful for plotting distributions.
fitted(demo_fit, dpar = "sigma")  # Another model parameter

# Evaluate at novel data
novel_data = data.frame(time = c(-5, 20, 300))  # Only predictors are needed
predict(demo_fit, newdata = novel_data, probs = c(0.025, 0.5, 0.975))
}
}
\seealso{
\code{\link{fitted.mcpfit}} \code{\link{predict.mcpfit}} \code{\link{residuals.mcpfit}} \code{\link{log_lik.mcpfit}}
}
\author{
Jonas Kristoffer Lindel√∏v \email{jonas@lindeloev.dk}
}
